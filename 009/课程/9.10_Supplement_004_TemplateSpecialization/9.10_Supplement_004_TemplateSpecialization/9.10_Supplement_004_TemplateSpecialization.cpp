// 9.10_Supplement_004_TemplateSpecialization.cpp : This file contains the 'main' function. Program execution begins and ends there.
//模板的特化。书上p388。
//0.模板的特化，就是指在确定了模板的构成后，对某些模板参数为特定值的情况进行特殊定义。
//0.注意，特化是指所有的模板参数都有了具体化的值。而如果只有部分模板参数有具体化的值，部分没有，则称为偏特化（之后会讲）。
//0.一旦对函数模板或类模板进行了特化，则相关的目标代码都会生成。因此，特化模板的定义应该放在源文件中。

#include <iostream>
#include "Header.h"
using namespace std;

template<class T>
void f(T t)
{
    cout << "This is a(n) " << typeid(t).name() << endl;
}

//1.函数模板的特化。
//1.要注意，对于函数模板而言，这里的“template<>”可加可不加，加了的话这里template的后面一定要加“<>”，不然就变成模板的显式声明了。
template<> void f(double t)
{
    cout << "Wow! This is a double" << endl;
}

/*----------------------------------------------------------------------------*/

//2.MyClass1的定义在Header.h中。

//2.类模板中成员函数的特化。
//2.函数成员的特化必须在已经对函数成员进行过一般形式的定义之后。
//2.如果在头文件中进行了成员函数的一般定义和同种特化定义，则其他源文件中再进行一般定义或同种特化定义会被认为是重复定义而报错。
//2.如果在头文件中进行了成员函数的一般定义（未进行特化定义），则同种特化定义在多个源文件中只能出现一次。
//2.如果在头文件中未进行一般定义和特化定义，则只能在多个源文件中出现一次一般定义。且则只有一般定义所在的源文件中，特化定义是有效的；其他源文件中的同种特化定义算是重复，会报错。此时如果一般定义和特化定义不再同一个源文件中，则特化定义是无效的；如果主函数文件中没有出现一般定义，主函数中却调用了函数，会因找不到函数体而报错。
//2.如果在头文件中未进行一般定义和特化定义，源文件中出现了多次成员函数的一般定义，则会被认为是重复定义而报错！
//2.如果只对成员函数进行了声明，没有进行一般定义，则特化会出错。
/*
template<class T>
struct MyClass1
{
    void f();
};

template<class T>
void MyClass1<T>::f()
{
    cout << "MyClass1.f()" << endl;
}
*/
//2.如果对模板的某个成员函数进行特化定义，则前面的“template<>”可加可不加。
//2.（一般定义在头文件中时）如果这里只写了声明，没有具体的函数体，则不会报错，但程序执行时还是会调用头文件中的一般情况下的成员函数f()。

void MyClass1<double>::f()
{
    cout << "MyClass1<double>.f()" << endl;
}

/*----------------------------------------------------------------------------*/

//3.类模板的特化。
//3.对类进行特化时，必须加“template<>”！
//3.而其成员函数也就相当于一般类的成员函数。
//3.如果在头文件中进行了一般定义和特化定义，则其他源文件中的再定义会被视为重复定义，导致报错。
//3.如果在头文件中进行了一般定义，则同种特化定义允许在不同源文件中重复出现（可能是因为书上p387提到的防止重复编译的机制）；但对特化类的同种成员函数的定义只能出现一次。如果特化定义不在主函数所在文件中，则主函数中无法调用特化的类；
//3.（接上一条）但如果特化类在主函数中有定义，而其成员函数的定义（及特化类的定义）在其他源文件中，则仍然可以实现调用（因为此时的特化的类相当于一般类，因此，可以把其中的成员函数的定义放到其他的源文件中！）；但如果主函数中没有定义特化类，则会报错（可能是因为其他源文件中的特化类的定义会被忽视，因此特化类的成员函数的定义就会与头文件中的成员函数的一般定义冲突）。
//3.如果将一般定义和特化定义都放到源文件中，则两者必须在同一个文件，否则会无法找到特化的原型。如果存在多个一般定义，会报错。如果不在主函数所在文件中，则主函数无法调用。
//3.如果只对类模板进行了声明，没有对其中的函数成员进行具体定义，特化依然可以发生。
template<>
struct MyClass2<bool>
{
    void f();
};
/*
//3.如果对类进行特化，然后对其函数进行定义时，不可以加“template<>”！因为此时“MyClass1<float>”已经相当于一个具体的一般的类。
//3.因为此时的特化的类相当于一般类，因此，可以把其中的成员函数的定义放到其他的源文件中！
void MyClass2<bool>::f()
{
    cout << "MyClass1<bool>.f()" << endl;
}
*/
/*----------------------------------------------------------------------------*/

template<class T>
struct MyClass3
{
    void f();
    void g();  
};
template<class T>
void MyClass3<T>::f()
{
    cout << "MyClass2.f()" << endl;
}
template<class T>
void MyClass3<T>::g()
{
    cout << "MyClass2.g()" << endl;
}

//4.对类模板进行特化时，会把类模板原有的成员都删除；而非像继承那样，派生类会保留基类的成员。
//4.这里在double类特化的模板中，没有重新定义g()。
template<>
struct MyClass3<double>
{
    //5.而如果没有具体定义特化的模板中的某个同名函数，虽然代码下面不会有红线，但代码是无法通过编译的。
    void f();
};

/*----------------------------------------------------------------------------*/

//6.MyClass3的类模板定义在头文件Header.h中。

//6.类模板中静态成员的特化。
//6.与成员函数类似，静态成员也必须在进行过一般形式的定义后，才可进行特化的定义。
//6.如果在头文件中对静态成员进行了一般形式的定义及特化的定义，则在其他源文件中再次进行一般形式的定义或特化的定义都会报错。
//6.如果在头文件中对静态成员进行了一般形式的定义（未进行特化定义），则在其他源文件中的再次进行一般形式的定义会报错；但在其他源文件在进行特化定义不会出错。
//6.这里与成员函数不同的地方在于，如果静态成员的一般定义和特化定义在头文件中未定义，而在多个源文件中定义时，均不会出现重复初始化的报错（一般类的静态成员如果在多个源文件中初始化，会报错）。但如果主函数文件中没有一般定义，而程序又调用了对应成员的话，会报错。
//6.如果只对静态数据成员进行了声明，而没有定义，则特化依然可以进行。
template<class T>
int MyClass4<T>::num(1);
//6.对类模板的静态成员进行特化时，“template<>”可加可不加（加上之后会出现红色波浪线，但编译不会报错）。
template<>
int MyClass4<double>::num(10);

/*----------------------------------------------------------------------------*/

//7.对于类模板中的，静态数据成员的及特化的静态数据成员的定义方式。
template<class T>
struct MyClass5
{
    static int num;
};
//7.以下三种都是正确的静态成员的正确的定义方式。（加注释是因为，如果不加，会出现重复定义的错误。）
template<class T>
int MyClass5<T>::num = 1;
/*
template<class T>
int MyClass5<T>::num(1);
template<class T>
int MyClass5<T>::num;
*/
//7.下面这种则是错误的定义方式，因为这会被编译器认为是对静态成员函数sum()的声明；而类体中又不存在这种成员函数。
/*
template<class T>
int MyClass5<T>::num();
*/
//7.以下三种都是特化静态成员的正确的定义方式。
int MyClass5<double>::num = 0; 
/*
int MyClass5<double>::num;
int MyClass5<double>::num(0);
*/
//7.下面这种则是错误的定义方式。原因和之前一样，num()被当成函数声明。
/*
int MyClass5<double>::num();
*/

/*----------------------------------------------------------------------------*/

int main()
{
    {
        cout << "Part 1" << endl;
        //1.可以看到，当f()的参数为int类型时，是对通用模板进行实例化。
        int a = 1;
        //1.而当f()的参数类型为double时，就是对特化的模板进行实例化。
        double b = 2;
        f(a);
        f(b);
        cout << endl;
    }

    {
        cout << "Part 2" << endl;
        MyClass1<int> mc1;
        MyClass1<double> mc2;
        //2.类模板的通用成员函数实例和特化后的成员函数实例。
        mc1.f();
        mc2.f();
        cout << endl;
    }

    {
        //3.特化类的成员函数。
        cout << "Part 3" << endl;
        MyClass2<bool> mc;
        mc.f();
        cout << endl;
    }

    {
        cout << "Part 4" << endl;
        MyClass3<int> mc1;
        MyClass3<double> mc2;
        mc1.f();
        mc1.g();
        //4.在创建对象后，double类特化的模板也就没有g()这个函数成员。
        //5.由于没有对double类特化的模板中的f()进行函数定义，因此下面的代码会报错。
        /*
        mc2.f();
        */
        cout << endl;
    }

    {
        //6.对类中静态成员的一般定义和特化定义。
        cout << "Part 5" << endl;
        MyClass4<int> mc1;
        cout << mc1.num << endl;
        MyClass4<double> mc2;
        cout << mc2.num << endl;
        cout << endl;
    }

    {
        cout << "Part 6" << endl;
        MyClass5<int> mc1;
        MyClass5<double> mc2;
        cout << mc1.num << endl;
        cout << mc2.num << endl;
    }
}
