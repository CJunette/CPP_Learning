// 6.3_ArrayAsParameter_003.cpp : This file contains the 'main' function. Program execution begins and ends there.
//这个工程源于我的一个疑问，为什么C++在允许数组访问溢出的同时，对多维数组的定义或做为实参的情况下有严格的要求。
//基本上只要弄明白了二维数组，也就弄明白多维数组了，所以这里全都用二维数组来举例。

#include <iostream>
using namespace std;

//1.首先是当多维数组作为形参的时候。当调用下面这个函数的时候，采用的实参必须是a[][4]，而不能是其他形式。
//1.但我们知道，实际上在函数调用的时候，实参传入的其实就是函数的首个元素的地址。而且C++允许溢出访问。
//1.既然如此，为什么数组的第二维度会成为约束条件？它是怎么实现约束的？
void change(int a[][4])
{
	cout << a[0][0] << endl;
}


int main()
{
	int a[] = { 1, 2, 3 };
	cout << sizeof(a) << endl;

	int b[] = { 4, 5, 6 };
	cout << sizeof(b) << endl;

	int *c[2] = { a, b };
	cout << sizeof(c) << endl;

	int d[][3] = { {1, 2, 3}, {4, 5, 6} };
	cout << sizeof(d) << endl;
		
	//上面的四种数组都不能成为change()函数的形参。
	/*
	change(a);
	change(b);
	change(c);
	change(d);
	*/

	//2.第二个问题，既然C++允许溢出访问，那为什么把所有元素写在一起的初始化方式是正确的，但分开到两个不同数组中（大小大于想要的第二维度的大小）就是错误的。为什么不能自动的将下面的那种形式去转换成上面的这种形式呢？
	int e[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	/*
	int e[2][5] = { {1, 2, 3, 4, 5, 6, 7}, {8, 9, 10} };
	*/

	//这里可以看出，C++是允许溢出访问的。访问到的值就是内存中紧接的值。
	int f[3][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
	cout << f[1][4] << endl;
	cout << f[2][1] << endl;

	//3.这里我只能对上述疑问做出一个猜测。
	//3.从实际的内存分配上来看，实际上多维数组是完全可以被等价的看做是有特定分段的一维数组。
	//3.我认为这里出现这些问题的关键不在与对于溢出访问的容忍上，而在于这个“特定分段”上。
	//3.如果我们要实现二维数组的准确访问，那就必须确定第二维度的大小，才能对现有的在内存上紧密排列的数组进行“分段”。换言之，二维数组的第二维度是实现二维数组能正确访问的功能的重要参数。
	//3.而且我认为这个第二维度是在声明时被确定的。以二维数组为形参的函数实际上接收到的实参就是数组的地址，其中应该也包含了第二维度的信息。
	//3.因为这里的传参是不涉及复制构造的，所以当形参和实参的第二维度存在不同时，形参和实参的两个不同的第二维度就意味着存在两个不同的实现数组正确访问的标准。
	//3.举例来说，如果形参要求a[][4]，而实参给了a[][3]。那当函数中想要访问a[1][2]的时候，到底是按形参给出第8个成员，还是按实参给出第7个成员？
	//3.如果这里的传参涉及复制构造，那也许还有一个机会将这两个维度进行统一。但既然是直接访问地址，也就不存在这种可能了。
	//4.对于数组的声明问题可能更简单一些。如果初始化数组的时候提供的第二维度的长度过长，那超出的部分到底是被删除还是按序继续放入数组就会出现矛盾。
	//5.总而言之就是，虽然在C++中对数组的访问并不存在严格的溢出报错，但在建立这些访问的时候会有严格的创建机制以保证多维数组的读取功能可以被正确的实现（尤其是对于多维数组）。

}