// 6.6_Pointer_002_Initialization.cpp : This file contains the 'main' function. Program execution begins and ends there.
//这里既包括了指针的初始化，也包括了指针的赋值运算，还有一些其他内容。

#include <iostream>
using namespace std;

int returnInt()
{
    return 1;
}

//11.函数是可以以地址作为返回值的。
int *returnPtr(int i)
{
    return &i;
}

int main()
{
    //1.指针变量中存放的只能是程序中合法获得的地址。注意是“合法获得”，不是什么地址都可以。
    //1.这里的合法地址指的是用“&”求得的已定义变量或对象的起始地址，或动态内存分配成功时返回的地址（这章马上回接触到）。
    int i = 1;
    int *ptr_1 = &i;
    //1.像下面的这种函数返回值也确实存在地址（在传参区域内），但是并不算是合法获得的地址，因此会报错。
    /*
    int *ptr = &returnInt();
    */
    //1.但这里有个例外，“0”是可以给指针赋值的，表示空指针。
    int *ptr_0 = 0;

    //2.指针的变量类型必须与所指向的初始化对象的变量类型一致。下面这个语句就会导致报错。
    /*
    double *p = &i;
    */

    //3.可以用一个已有合法值的指针去初始化另一个同类型的指针。
    int *ptr_2 = ptr_1;

    //4.不要用内部的非静态变量去初始化一个static指针。
    //4.下面这个语句虽然编译器没有报错，但实际上是十分危险的语句。因为变量j的作用域到“{}”结束为止，换言之到“{}”之外，变量j在内存中的地址就会被收回，这个地址之后可能被用作其他用处。
    //4.如果这里有个静态指针一直指向那个地址，则如果这个地址被用作其他用途，那指针想要保存的值就丢失了。
    static int *ptr_3;        
    {
        int j = 2;
        ptr_3 = &j;
        cout << ptr_3 << endl;
        cout << *ptr_3 << endl;
    }
    cout << ptr_3 << endl;
    cout << *ptr_3 << endl;

    //5.未初始化时，指针内的值为空。此时可以查看指针自身所在的地址和指针此时存放的空值。
    //5.但因为地址为空，所以不能查看指针所指向的内容。
    //5.[对上述两个表达进行修正]未初始化时，指针并不是所谓的空指针。如果此时没有对指针进行任何操作就试图去访问指针所在的内存地址中储存的内容是会直接报错的。就这一点而言，指针变量和一般数据类型变量有很大差别。
    int *ptr_4;
    //5.这里有个非常奇怪的问题。如果像这样先输出指针所在的地址，在输出指针保存的地址，能正常运行；但如果只输出指针保存的地址，系统就报错（使用未初始化的内存）。
    cout << &ptr_4 << endl;
    cout << ptr_4 << endl;
    /*
    cout << *ptr_4 << endl;
    */
    int *ptr_4_0 = 0;
    cout << ptr_4_0 << endl;
    //5.可以看到，这里指向未初始化的指针（ptr_4_1）的指针（ptr_4_2）所访问到被储存的地址并不是空指针所对应的地址。
    //5.我的猜测是，应该是对未初始化的指针的任何涉及其自身地址的操作都会为这个未初始化的指针赋一个默认值。
    int *ptr_4_1;
    int **ptr_4_2 = &ptr_4_1;
    cout << *ptr_4_2 << endl;


    //6.允许定义或声明指向void类型的指针，该指针可以用来存放任何类型的数据的地址。
    //6.但是这个指针只能用于存放地址，不能用于访问地址所指向的空间！
    //6.但是不能定义无类型的变量！原因在于指针的内存大小是确定的，但变量的内存大小是不确定的。    
    void *general = &i;
    //6.如果想要访问void类型的指针所指向的数据，必须进行强制类型转换。
    cout << *static_cast<int *>(general) << endl;
    //6.如果在转换指针时弄错数据类型，虽然程序不会报错，但是得到的值会出现错误。
    cout << *static_cast<double *>(general) << endl;

    //7.C++11以后可以用“nullptr”更安全地来表示空指针。
    int *ptr_5 = nullptr;

    int k = 3;
    int l = 4;
    //8.指向常量的指针不能改变指针指向的地址中存放的值（即使它所指向的值不是常量），但可以改变指针指向的地址。这样的指针叫常量指针。
    //8.结合以前讲到过的常函数。如果一个类的常函数中有对常指针的操作，那么这个操作既不可以改变指针指向地址的值，也不可以改变指针的指向。
    //8.这里也可以写成“int const *ptr_6= &i;”。
    const int *ptr_6 = &k;
    /*
    *ptr_6 = 5;
    */
    ptr_6 = &l;
    //8.常量指针只是说对指针而言不能修改指向地址内存放的值，并不是说这个值一定是不可修改了的。
    k = 5;

    //9.看到上面的指向常量的指针，我就像尝试一下，能否通过让指针指向常量标识符，然后尝试修改这个常量标识符的值。
    //9.结果是，一般的指针是不能指向常量标识符的。必须是被const修饰的指向常量的指针才能指向常量标识符。
    const int m = 5;
    ptr_6 = &m;
    //9.下面的代码会报错。
    /*
    int *ptr_7 = &m;
    */

    //10.同样的，我们也可以定义一个不能改变指向的指针，也就是常指针。
    int *const ptr_8 = &i;
    //10.此时，下面的这个操作时会报错的。
    /*
    ptr_8 = &l;
    */    
    //10.但此时，指针所指向的地址里存放的值是可以改变的。
    *ptr_8 = 2;
}
