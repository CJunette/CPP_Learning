// 6.6_Pointer_002_Initialization.cpp : This file contains the 'main' function. Program execution begins and ends there.
//这里既包括了指针的初始化，也包括了指针的赋值运算，还有一些其他内容。

#include <iostream>
using namespace std;

int returnInt()
{
    return 1;
}

//11.函数是可以以地址作为返回值的。
int *returnPtr(int i)
{
    return &i;
}

int main()
{
    //1.指针变量中存放的只能是程序中合法获得的地址。注意是“合法获得”，不是什么地址都可以。
    //1.这里的合法地址指的是用“&”求得的已定义变量或对象的起始地址，或动态内存分配成功时返回的地址（这章马上回接触到）。
    int i = 1;
    int *ptr_1 = &i;
    //1.像下面的这种函数返回值也确实存在地址（在传参区域内），但是并不算是合法获得的地址，因此会报错。
    /*
    int *ptr = &returnInt();
    */
    //1.但这里有个例外，“0”是可以给指针赋值的，表示空指针。
    int *ptr_0 = 0;

    //2.指针的变量类型必须与所指向的初始化对象的变量类型一致。下面这个语句就会导致报错。
    /*
    double *p = &i;
    */

    //3.可以用一个已有合法值的指针去初始化另一个同类型的指针。
    int *ptr_2 = ptr_1;

    //4.不要用内部的非静态变量去初始化一个static指针。
    //4.下面这个语句虽然编译器没有报错，但实际上是十分危险的语句。因为变量j的作用域到“{}”结束为止，换言之到“{}”之外，变量j在内存中的地址就会被收回，这个地址之后可能被用作其他用处。
    //4.如果这里有个静态指针一直指向那个地址，则如果这个地址被用作其他用途，那指针想要保存的值就丢失了。
    static int *ptr_3;        
    {
        int j = 2;
        ptr_3 = &j;
        cout << ptr_3 << endl;
        cout << *ptr_3 << endl;
    }
    cout << ptr_3 << endl;
    cout << *ptr_3 << endl;

    //5.未初始化时，指针内的值为空。此时可以查看指针自身所在的地址和指针此时存放的空值。
    //5.但因为地址为空，所以不能查看指针所指向的内容。
    int *ptr_4;
    cout << &ptr_4 << endl;
    cout << ptr_4 << endl;
    /*
    cout << *ptr_4 << endl;
    */

    //6.允许定义或声明指向void类型的指针，该指针可以用来存放任何类型的数据的地址。
    //6.但是这个指针只能用于存放地址，不能用于访问地址所指向的空间！
    //6.但是不能定义无类型的变量！原因在于指针的内存大小是确定的，但变量的内存大小是不确定的。    
    void *general = &i;
    //6.如果想要访问void类型的指针所指向的数据，必须进行强制类型转换。
    cout << *static_cast<int *>(general) << endl;
    //6.如果在转换指针时弄错数据类型，虽然程序不会报错，但是得到的值会出现错误。
    cout << *static_cast<double *>(general) << endl;

    //7.C++11以后可以用“nullptr”更安全地来表示空指针。
    int *ptr_5 = nullptr;

    int k = 3;
    int l = 4;
    //8.指向常量的指针不能改变指针指向的地址中存放的值（即使它所指向的值不是常量），但可以改变指针指向的地址。这样的指针叫常量指针。
    //8.结合以前讲到过的常函数。如果一个类的常函数中有对常指针的操作，那么这个操作既不可以改变指针指向地址的值，也不可以改变指针的指向。
    //8.这里也可以写成“int const *ptr_6= &i;”。
    const int *ptr_6 = &k;
    /*
    *ptr_6 = 5;
    */
    ptr_6 = &l;

    //9.看到上面的指向常量的指针，我就像尝试一下，能否通过让指针指向常量标识符，然后尝试修改这个常量标识符的值。
    //9.结果是，一般的指针是不能指向常量标识符的。必须是被const修饰的指向常量的指针才能指向常量标识符。
    const int m = 5;
    ptr_6 = &m;
    //9.下面的代码会报错。
    /*
    int *ptr_7 = &m;
    */

    //10.同样的，我们也可以定义一个不能改变指向的指针，也就是常指针。
    int *const ptr_8 = &i;
    //10.此时，下面的这个操作时会报错的。
    /*
    ptr_8 = &l;
    */    
    //10.但此时，指针所指向的地址里存放的值是可以改变的。
    *ptr_8 = 2;
}
